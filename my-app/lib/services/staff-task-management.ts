import { connectToDatabase } from '@/lib/mongodb'

export interface StaffTask {
  id: string
  propertyId: string
  bookingId: string

  // Task classification
  category: 'guest_services' | 'housekeeping' | 'maintenance' | 'front_desk' | 'food_beverage' | 'transport' | 'administrative'
  type: string
  priority: 'low' | 'medium' | 'high' | 'urgent'
  status: 'pending' | 'assigned' | 'in_progress' | 'completed' | 'cancelled' | 'overdue'

  // Task details
  title: string
  description: string
  instructions?: string
  estimatedDuration: number // minutes
  deadline?: Date

  // Booking context
  guestName: string
  roomNumber: string
  checkInDate: Date
  checkOutDate: Date
  specialRequests?: string[]

  // Assignment
  assignedTo?: {
    staffId: string
    staffName: string
    department: string
    role: string
    contactInfo: string
  }
  assignedAt?: Date
  assignedBy?: string

  // Execution tracking
  startedAt?: Date
  completedAt?: Date
  actualDuration?: number
  notes?: string
  photos?: string[]

  // Dependencies
  dependsOn?: string[] // other task IDs
  blockedBy?: string[] // other task IDs that block this task
  prerequisiteCompleted: boolean

  // Guest interaction
  requiresGuestPresence: boolean
  guestNotified: boolean
  guestFeedback?: {
    rating: number
    comment?: string
    submittedAt: Date
  }

  // Automation
  autoGenerated: boolean
  parentTaskId?: string
  recurringTaskId?: string

  // Metadata
  createdAt: Date
  createdBy: string
  lastUpdated: Date
  updatedBy: string
}

export interface TaskTemplate {
  id: string
  name: string
  category: StaffTask['category']
  type: string
  description: string
  instructions: string
  estimatedDuration: number
  priority: StaffTask['priority']
  department: string
  triggers: {
    bookingEvents: ('booking_confirmed' | 'guest_checked_in' | 'guest_checked_out' | 'booking_cancelled')[]
    timeBeforeCheckin?: number // hours
    timeAfterCheckout?: number // hours
    conditions?: {
      roomType?: string[]
      guestType?: string[]
      specialRequests?: string[]
    }
  }
  assignmentRules: {
    autoAssign: boolean
    preferredRole?: string
    workloadBalancing: boolean
    skillRequirements?: string[]
  }
}

export interface StaffWorkload {
  staffId: string
  staffName: string
  department: string
  shift: {
    start: string
    end: string
    date: Date
  }
  tasks: {
    pending: number
    assigned: number
    inProgress: number
    completed: number
    overdue: number
  }
  totalWorkload: number // in minutes
  availability: 'available' | 'busy' | 'overloaded' | 'off_duty'
  skills: string[]
  currentLocation?: string
}

export interface TaskAnalytics {
  totalTasks: number
  completionRate: number
  averageCompletionTime: number
  overdueRate: number
  staffPerformance: Array<{
    staffId: string
    staffName: string
    tasksCompleted: number
    averageTime: number
    qualityScore: number
    onTimeCompletion: number
  }>
  categoryDistribution: { [category: string]: number }
  guestSatisfaction: {
    averageRating: number
    responseRate: number
    commonComplaints: string[]
  }
  trends: Array<{
    date: string
    tasksCreated: number
    tasksCompleted: number
    averageTime: number
  }>
}

export class StaffTaskManagementService {
  private static readonly TASK_TEMPLATES: TaskTemplate[] = [
    {
      id: 'welcome_setup',
      name: 'Welcome Setup',
      category: 'guest_services',
      type: 'room_preparation',
      description: 'Prepare welcome amenities and room setup for arriving guest',
      instructions: 'Set up welcome drinks, arrange flowers, check room temperature, ensure all amenities are stocked',
      estimatedDuration: 15,
      priority: 'medium',
      department: 'guest_services',
      triggers: {
        bookingEvents: ['booking_confirmed'],
        timeBeforeCheckin: 2
      },
      assignmentRules: {
        autoAssign: true,
        preferredRole: 'guest_services_agent',
        workloadBalancing: true
      }
    },
    {
      id: 'checkin_preparation',
      name: 'Check-in Preparation',
      category: 'front_desk',
      type: 'arrival_prep',
      description: 'Prepare guest registration documents and room keys',
      instructions: 'Print registration forms, prepare room keys, review guest preferences, check special requests',
      estimatedDuration: 10,
      priority: 'high',
      department: 'front_desk',
      triggers: {
        bookingEvents: ['booking_confirmed'],
        timeBeforeCheckin: 1
      },
      assignmentRules: {
        autoAssign: true,
        preferredRole: 'front_desk_agent',
        workloadBalancing: true
      }
    },
    {
      id: 'post_checkout_inspection',
      name: 'Post Check-out Inspection',
      category: 'housekeeping',
      type: 'room_inspection',
      description: 'Inspect room condition after guest departure',
      instructions: 'Check for damages, inventory missing items, assess cleaning requirements',
      estimatedDuration: 20,
      priority: 'high',
      department: 'housekeeping',
      triggers: {
        bookingEvents: ['guest_checked_out'],
        timeAfterCheckout: 0
      },
      assignmentRules: {
        autoAssign: true,
        preferredRole: 'housekeeper',
        workloadBalancing: true
      }
    },
    {
      id: 'vip_concierge_service',
      name: 'VIP Concierge Service',
      category: 'guest_services',
      type: 'concierge',
      description: 'Provide personalized concierge service for VIP guests',
      instructions: 'Contact guest to offer assistance, arrange special services, provide local recommendations',
      estimatedDuration: 30,
      priority: 'high',
      department: 'guest_services',
      triggers: {
        bookingEvents: ['guest_checked_in'],
        conditions: {
          guestType: ['vip', 'returning']
        }
      },
      assignmentRules: {
        autoAssign: true,
        preferredRole: 'concierge',
        workloadBalancing: false,
        skillRequirements: ['vip_service', 'local_knowledge']
      }
    },
    {
      id: 'special_dietary_coordination',
      name: 'Special Dietary Coordination',
      category: 'food_beverage',
      type: 'dietary_prep',
      description: 'Coordinate special dietary requirements with kitchen',
      instructions: 'Review guest dietary restrictions, brief kitchen staff, ensure proper meal preparation',
      estimatedDuration: 25,
      priority: 'medium',
      department: 'food_beverage',
      triggers: {
        bookingEvents: ['booking_confirmed'],
        timeBeforeCheckin: 4,
        conditions: {
          specialRequests: ['vegetarian', 'vegan', 'gluten_free', 'allergies']
        }
      },
      assignmentRules: {
        autoAssign: true,
        preferredRole: 'f&b_coordinator',
        workloadBalancing: true,
        skillRequirements: ['dietary_knowledge']
      }
    }
  ]

  static async createTasksFromBookingEvent(bookingId: string, event: 'booking_confirmed' | 'guest_checked_in' | 'guest_checked_out' | 'booking_cancelled'): Promise<{ success: boolean; tasksCreated?: number; error?: string }> {
    try {
      await connectToDatabase()

      const Booking = (await import('@/models/Booking')).default
      const Room = (await import('@/models/Room')).default

      const booking = await Booking.findById(bookingId).populate('roomId').populate('userId')
      if (!booking) {
        return { success: false, error: 'Booking not found' }
      }

      const room = await Room.findById(booking.roomId)
      if (!room) {
        return { success: false, error: 'Room not found' }
      }

      const applicableTemplates = this.TASK_TEMPLATES.filter(template => {
        // Check if template is triggered by this event
        if (!template.triggers.bookingEvents.includes(event)) {
          return false
        }

        // Check conditions if any
        if (template.triggers.conditions) {
          const conditions = template.triggers.conditions

          if (conditions.roomType && !conditions.roomType.includes(room.roomType)) {
            return false
          }

          if (conditions.guestType && booking.guestType && !conditions.guestType.includes(booking.guestType)) {
            return false
          }

          if (conditions.specialRequests) {
            const hasMatchingRequest = booking.specialRequests?.some(request =>
              conditions.specialRequests!.some(condition =>
                request.toLowerCase().includes(condition.toLowerCase())
              )
            )
            if (!hasMatchingRequest) {
              return false
            }
          }
        }

        return true
      })

      const tasksToCreate: StaffTask[] = []

      for (const template of applicableTemplates) {
        const taskId = `ST-${Date.now()}-${Math.random().toString(36).substr(2, 6).toUpperCase()}`

        // Calculate deadline based on trigger timing
        let deadline: Date | undefined
        if (template.triggers.timeBeforeCheckin) {
          deadline = new Date(booking.checkIn.getTime() - template.triggers.timeBeforeCheckin * 60 * 60 * 1000)
        } else if (template.triggers.timeAfterCheckout) {
          deadline = new Date(booking.checkOut.getTime() + template.triggers.timeAfterCheckout * 60 * 60 * 1000)
        }

        const task: StaffTask = {
          id: taskId,
          propertyId: booking.propertyId.toString(),
          bookingId,
          category: template.category,
          type: template.type,
          priority: template.priority,
          status: 'pending',
          title: template.name,
          description: template.description,
          instructions: template.instructions,
          estimatedDuration: template.estimatedDuration,
          deadline,
          guestName: booking.guestName,
          roomNumber: room.roomNumber,
          checkInDate: booking.checkIn,
          checkOutDate: booking.checkOut,
          specialRequests: booking.specialRequests,
          prerequisiteCompleted: true,
          requiresGuestPresence: template.category === 'guest_services',
          guestNotified: false,
          autoGenerated: true,
          createdAt: new Date(),
          createdBy: 'system',
          lastUpdated: new Date(),
          updatedBy: 'system'
        }

        tasksToCreate.push(task)

        // Auto-assign if enabled in template
        if (template.assignmentRules.autoAssign) {
          const assignment = await this.findBestStaffAssignment(task, template)
          if (assignment) {
            task.assignedTo = assignment
            task.assignedAt = new Date()
            task.assignedBy = 'system'
            task.status = 'assigned'
          }
        }
      }

      if (tasksToCreate.length > 0) {
        // Store tasks
        const { MongoClient } = await import('mongodb')
        const client = new MongoClient(process.env.MONGODB_URI!)
        await client.connect()

        const db = client.db()
        const collection = db.collection('staff_tasks')
        await collection.insertMany(tasksToCreate)

        await client.close()

        // Send notifications for assigned tasks
        for (const task of tasksToCreate.filter(t => t.assignedTo)) {
          await this.notifyStaffAssignment(task)
        }
      }

      return { success: true, tasksCreated: tasksToCreate.length }

    } catch (error) {
      console.error('Error creating tasks from booking event:', error)
      return { success: false, error: 'Failed to create tasks' }
    }
  }

  static async assignTask(taskId: string, staffId: string, assignedBy: string): Promise<{ success: boolean; error?: string }> {
    try {
      const { MongoClient } = await import('mongodb')
      const client = new MongoClient(process.env.MONGODB_URI!)
      await client.connect()

      const db = client.db()
      const tasksCollection = db.collection('staff_tasks')
      const staffCollection = db.collection('staff_members')

      const task = await tasksCollection.findOne({ id: taskId }) as StaffTask
      if (!task) {
        await client.close()
        return { success: false, error: 'Task not found' }
      }

      const staff = await staffCollection.findOne({ id: staffId })
      if (!staff) {
        await client.close()
        return { success: false, error: 'Staff member not found' }
      }

      const assignment = {
        staffId,
        staffName: staff.name,
        department: staff.department,
        role: staff.role,
        contactInfo: staff.phone || staff.email
      }

      await tasksCollection.updateOne(
        { id: taskId },
        {
          $set: {
            assignedTo: assignment,
            assignedAt: new Date(),
            assignedBy,
            status: 'assigned',
            lastUpdated: new Date(),
            updatedBy: assignedBy
          }
        }
      )

      await client.close()

      // Notify assigned staff
      await this.notifyStaffAssignment(task)

      return { success: true }

    } catch (error) {
      console.error('Error assigning task:', error)
      return { success: false, error: 'Failed to assign task' }
    }
  }

  static async updateTaskStatus(taskId: string, status: StaffTask['status'], updates?: {
    notes?: string
    photos?: string[]
    actualDuration?: number
    guestFeedback?: StaffTask['guestFeedback']
  }): Promise<{ success: boolean; error?: string }> {
    try {
      const { MongoClient } = await import('mongodb')
      const client = new MongoClient(process.env.MONGODB_URI!)
      await client.connect()

      const db = client.db()
      const collection = db.collection('staff_tasks')

      const updateData: any = {
        status,
        lastUpdated: new Date()
      }

      if (status === 'in_progress') {
        updateData.startedAt = new Date()
      } else if (status === 'completed') {
        updateData.completedAt = new Date()
      }

      if (updates) {
        Object.assign(updateData, updates)
      }

      await collection.updateOne(
        { id: taskId },
        { $set: updateData }
      )

      // Check for dependent tasks
      if (status === 'completed') {
        await this.processDependentTasks(taskId)
      }

      await client.close()

      return { success: true }

    } catch (error) {
      console.error('Error updating task status:', error)
      return { success: false, error: 'Failed to update task status' }
    }
  }

  static async getTasksByProperty(propertyId: string, filters?: {
    status?: string
    category?: string
    assignedTo?: string
    date?: Date
    bookingId?: string
  }): Promise<StaffTask[]> {
    try {
      const { MongoClient } = await import('mongodb')
      const client = new MongoClient(process.env.MONGODB_URI!)
      await client.connect()

      const db = client.db()
      const collection = db.collection('staff_tasks')

      const query: any = { propertyId }

      if (filters) {
        if (filters.status) query.status = filters.status
        if (filters.category) query.category = filters.category
        if (filters.assignedTo) query['assignedTo.staffId'] = filters.assignedTo
        if (filters.bookingId) query.bookingId = filters.bookingId
        if (filters.date) {
          const startOfDay = new Date(filters.date)
          startOfDay.setHours(0, 0, 0, 0)
          const endOfDay = new Date(filters.date)
          endOfDay.setHours(23, 59, 59, 999)

          query.$or = [
            { deadline: { $gte: startOfDay, $lte: endOfDay } },
            { createdAt: { $gte: startOfDay, $lte: endOfDay } }
          ]
        }
      }

      const tasks = await collection.find(query).sort({ deadline: 1, priority: -1 }).toArray()

      await client.close()

      return tasks as StaffTask[]

    } catch (error) {
      console.error('Error fetching tasks:', error)
      return []
    }
  }

  static async getStaffWorkload(propertyId: string, date: Date): Promise<StaffWorkload[]> {
    try {
      const { MongoClient } = await import('mongodb')
      const client = new MongoClient(process.env.MONGODB_URI!)
      await client.connect()

      const db = client.db()
      const tasksCollection = db.collection('staff_tasks')
      const staffCollection = db.collection('staff_members')

      const startOfDay = new Date(date)
      startOfDay.setHours(0, 0, 0, 0)
      const endOfDay = new Date(date)
      endOfDay.setHours(23, 59, 59, 999)

      // Get tasks for the day
      const tasks = await tasksCollection.find({
        propertyId,
        $or: [
          { deadline: { $gte: startOfDay, $lte: endOfDay } },
          { createdAt: { $gte: startOfDay, $lte: endOfDay } }
        ]
      }).toArray() as StaffTask[]

      // Get staff members
      const staff = await staffCollection.find({ propertyId }).toArray()

      const workloads: StaffWorkload[] = staff.map(member => {
        const staffTasks = tasks.filter(t => t.assignedTo?.staffId === member.id)

        const taskCounts = {
          pending: staffTasks.filter(t => t.status === 'pending').length,
          assigned: staffTasks.filter(t => t.status === 'assigned').length,
          inProgress: staffTasks.filter(t => t.status === 'in_progress').length,
          completed: staffTasks.filter(t => t.status === 'completed').length,
          overdue: staffTasks.filter(t => t.status === 'overdue').length
        }

        const totalWorkload = staffTasks.reduce((sum, task) => {
          return sum + (task.actualDuration || task.estimatedDuration)
        }, 0)

        let availability: StaffWorkload['availability'] = 'available'
        if (totalWorkload > 480) availability = 'overloaded' // > 8 hours
        else if (totalWorkload > 360) availability = 'busy' // > 6 hours

        return {
          staffId: member.id,
          staffName: member.name,
          department: member.department,
          shift: member.shift || { start: '09:00', end: '17:00', date },
          tasks: taskCounts,
          totalWorkload,
          availability,
          skills: member.skills || [],
          currentLocation: member.currentLocation
        }
      })

      await client.close()

      return workloads

    } catch (error) {
      console.error('Error calculating staff workload:', error)
      return []
    }
  }

  static async getTaskAnalytics(propertyId: string, period?: { from: Date; to: Date }): Promise<TaskAnalytics> {
    try {
      const { MongoClient } = await import('mongodb')
      const client = new MongoClient(process.env.MONGODB_URI!)
      await client.connect()

      const db = client.db()
      const collection = db.collection('staff_tasks')

      const query: any = { propertyId }
      if (period) {
        query.createdAt = {
          $gte: period.from,
          $lte: period.to
        }
      }

      const tasks = await collection.find(query).toArray() as StaffTask[]

      const completedTasks = tasks.filter(t => t.status === 'completed')
      const overdueTasks = tasks.filter(t =>
        t.deadline && new Date() > t.deadline && t.status !== 'completed'
      )

      // Calculate staff performance
      const staffStats: { [staffId: string]: { name: string; tasks: number; totalTime: number; onTime: number; ratings: number[] } } = {}

      completedTasks.forEach(task => {
        if (task.assignedTo) {
          if (!staffStats[task.assignedTo.staffId]) {
            staffStats[task.assignedTo.staffId] = {
              name: task.assignedTo.staffName,
              tasks: 0,
              totalTime: 0,
              onTime: 0,
              ratings: []
            }
          }

          const stats = staffStats[task.assignedTo.staffId]
          stats.tasks++
          stats.totalTime += task.actualDuration || task.estimatedDuration

          if (task.deadline && task.completedAt && task.completedAt <= task.deadline) {
            stats.onTime++
          }

          if (task.guestFeedback) {
            stats.ratings.push(task.guestFeedback.rating)
          }
        }
      })

      // Calculate category distribution
      const categoryDistribution: { [category: string]: number } = {}
      tasks.forEach(task => {
        categoryDistribution[task.category] = (categoryDistribution[task.category] || 0) + 1
      })

      const analytics: TaskAnalytics = {
        totalTasks: tasks.length,
        completionRate: tasks.length > 0 ? (completedTasks.length / tasks.length) * 100 : 0,
        averageCompletionTime: completedTasks.reduce((sum, t) => sum + (t.actualDuration || t.estimatedDuration), 0) / completedTasks.length || 0,
        overdueRate: tasks.length > 0 ? (overdueTasks.length / tasks.length) * 100 : 0,
        staffPerformance: Object.entries(staffStats).map(([staffId, stats]) => ({
          staffId,
          staffName: stats.name,
          tasksCompleted: stats.tasks,
          averageTime: stats.totalTime / stats.tasks,
          qualityScore: stats.ratings.length > 0 ? stats.ratings.reduce((sum, r) => sum + r, 0) / stats.ratings.length : 0,
          onTimeCompletion: stats.tasks > 0 ? (stats.onTime / stats.tasks) * 100 : 0
        })),
        categoryDistribution,
        guestSatisfaction: {
          averageRating: 0,
          responseRate: 0,
          commonComplaints: []
        },
        trends: []
      }

      // Calculate guest satisfaction
      const feedbackTasks = completedTasks.filter(t => t.guestFeedback)
      if (feedbackTasks.length > 0) {
        analytics.guestSatisfaction = {
          averageRating: feedbackTasks.reduce((sum, t) => sum + t.guestFeedback!.rating, 0) / feedbackTasks.length,
          responseRate: (feedbackTasks.length / completedTasks.length) * 100,
          commonComplaints: [] // Would need more sophisticated analysis
        }
      }

      await client.close()

      return analytics

    } catch (error) {
      console.error('Error calculating task analytics:', error)
      throw error
    }
  }

  private static async findBestStaffAssignment(task: StaffTask, template: TaskTemplate): Promise<StaffTask['assignedTo'] | null> {
    try {
      const { MongoClient } = await import('mongodb')
      const client = new MongoClient(process.env.MONGODB_URI!)
      await client.connect()

      const db = client.db()
      const staffCollection = db.collection('staff_members')

      const query: any = {
        propertyId: task.propertyId,
        department: template.department,
        status: 'active'
      }

      if (template.assignmentRules.preferredRole) {
        query.role = template.assignmentRules.preferredRole
      }

      if (template.assignmentRules.skillRequirements) {
        query.skills = { $in: template.assignmentRules.skillRequirements }
      }

      const availableStaff = await staffCollection.find(query).toArray()

      if (availableStaff.length === 0) {
        await client.close()
        return null
      }

      // If workload balancing is enabled, find staff with least workload
      let selectedStaff = availableStaff[0]

      if (template.assignmentRules.workloadBalancing && availableStaff.length > 1) {
        const workloads = await Promise.all(
          availableStaff.map(async (staff) => {
            const tasksCollection = db.collection('staff_tasks')
            const currentTasks = await tasksCollection.find({
              'assignedTo.staffId': staff.id,
              status: { $in: ['assigned', 'in_progress'] }
            }).toArray()

            const workload = currentTasks.reduce((sum, t: any) => sum + t.estimatedDuration, 0)

            return { staff, workload }
          })
        )

        selectedStaff = workloads.reduce((min, current) =>
          current.workload < min.workload ? current : min
        ).staff
      }

      await client.close()

      return {
        staffId: selectedStaff.id,
        staffName: selectedStaff.name,
        department: selectedStaff.department,
        role: selectedStaff.role,
        contactInfo: selectedStaff.phone || selectedStaff.email
      }

    } catch (error) {
      console.error('Error finding staff assignment:', error)
      return null
    }
  }

  private static async processDependentTasks(completedTaskId: string): Promise<void> {
    try {
      const { MongoClient } = await import('mongodb')
      const client = new MongoClient(process.env.MONGODB_URI!)
      await client.connect()

      const db = client.db()
      const collection = db.collection('staff_tasks')

      // Find tasks that depend on this completed task
      const dependentTasks = await collection.find({
        dependsOn: completedTaskId,
        status: 'pending'
      }).toArray() as StaffTask[]

      for (const task of dependentTasks) {
        // Check if all dependencies are completed
        const allDependencies = task.dependsOn || []
        const completedDependencies = await collection.find({
          id: { $in: allDependencies },
          status: 'completed'
        }).toArray()

        if (completedDependencies.length === allDependencies.length) {
          // All dependencies completed, mark as ready
          await collection.updateOne(
            { id: task.id },
            {
              $set: {
                prerequisiteCompleted: true,
                lastUpdated: new Date()
              }
            }
          )
        }
      }

      await client.close()

    } catch (error) {
      console.error('Error processing dependent tasks:', error)
    }
  }

  private static async notifyStaffAssignment(task: StaffTask): Promise<void> {
    try {
      if (!task.assignedTo) return

      const SMSService = (await import('./sms-service')).SMSService

      const message = `New task assigned: ${task.title} for guest ${task.guestName} in room ${task.roomNumber}. ${task.deadline ? `Deadline: ${task.deadline.toLocaleString()}` : ''} Task ID: ${task.id}`

      await SMSService.sendSMS({
        to: task.assignedTo.contactInfo,
        message,
        priority: task.priority === 'urgent' ? 'high' : 'normal',
        category: 'task_assignment'
      })

    } catch (error) {
      console.error('Error notifying staff assignment:', error)
    }
  }
}